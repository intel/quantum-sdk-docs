<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Overview of FLEQ compilation &#8212; Intel® Quantum SDK API v1.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=45183d27"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Support" href="support.html" />
    <link rel="prev" title="Debugging" href="debugging.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="overview-of-fleq-compilation">
<span id="compilation-overview"></span><h1>Overview of FLEQ compilation<a class="headerlink" href="#overview-of-fleq-compilation" title="Link to this heading">¶</a></h1>
<p>Though not strictly required, it can be helpful to understand how the
FLEQ compilation stage of the Intel® Quantum Compiler (IQC) functions in order to better understand how to
best leverage the tools. By design, FLEQ compilation is one stage in the
transformation of the LLVM intermediate representation (IR) (generated from the source code) into a hybrid quantum-classical
binary executable.</p>
<p>FLEQ compilation happens just after many of the classical code IR optimizations
(standard LLVM loop unrolling, inlining, and optimization), but just before most
quantum code IR transformations (quantum optimization, native gate decomposition,
qubit placement, routing and scheduling). As a result, FLEQ compilation must meet the IR constraints of
fully formed QBBs (in IR).</p>
<p>In particular, FLEQ compilation produces quantum logic in the form of a PCOAST
graph for each generated QBB, which is passed to a circuit synthesis stage used by the <code class="docutils literal notranslate"><span class="pre">O1</span></code>
optimization flag. This is why the optimization flags <code class="docutils literal notranslate"><span class="pre">O0</span></code> versus <code class="docutils literal notranslate"><span class="pre">O1</span></code> have
no appreciable effect on the gate sequences generated by FLEQ; they pass through
this synthesis step no matter the flag. The PCOAST graph was chosen as it is an
efficient, easily manipulated quantum IR, but future versions of FLEQ may use
different IRs.</p>
<p>Note that the use of <code class="docutils literal notranslate"><span class="pre">O0</span></code> versus <code class="docutils literal notranslate"><span class="pre">O1</span></code> does still affect the way quantum
kernel functions are processed later on in the compiler, regardless of the use
of FLEQ.</p>
<p>Before FLEQ compilation, all the user-facing FLEQ functions are replaced with
IQC builtin LLVM intrinsic function equivalents (in other words, they are opaque
to core LLVM). The FLEQ builtins are then processed by FLEQ compilation and
ultimately removed so that none of these builtins are present in the IR after
the FLEQ compilation stage.</p>
<p>To begin FLEQ compilation, the IQC identifies each evaluation
call (<code class="docutils literal notranslate"><span class="pre">eval_hold</span></code> or <code class="docutils literal notranslate"><span class="pre">eval_release</span></code>) and from it builds a <em>FLEQ Evaluation Graph</em> or FLEQ graph. Each <code class="docutils literal notranslate"><span class="pre">QExpr</span></code> function
in the dependency of the evaluation call is represented as a node in the FLEQ graph with edges to <code class="docutils literal notranslate"><span class="pre">QExpr</span></code>
arguments to that function.</p>
<p>From the FLEQ graph, the quantum logic is then built in the place of
the call through three primary steps:</p>
<ol class="arabic">
<li><p><strong>Validation and Conditioning.</strong> Each user-defined function in the FLEQ graph is checked to
verify that it satisfies the conditions outlined in <a class="reference internal" href="intro.html#basics"><span class="std std-ref">Basic concepts</span></a>. The function is
then “conditioned”, i.e. manipulated so as to be amenable to the rest of the process. As discussed in
<a class="reference internal" href="classical-quantum-ordering.html#classical"><span class="std std-ref">Ordering of classical and quantum operations</span></a>, this identifies three sections, similar to the core IQC: the pre-quantum section, the quantum section
and the post-quantum section. For functions which do not use imperative gate calls (i.e. not
generated by <code class="docutils literal notranslate"><span class="pre">convert</span></code> or use of <code class="docutils literal notranslate"><span class="pre">this_as_expr</span></code>), the post-quantum section is trivial.</p></li>
<li><p><strong>Inlining and Unrolling.</strong> All user-defined functions are inlined in the place of the evaluation
call. The structure of the FLEQ graph indicates recursion through loops in the graph. So, inlining
is performed in two steps.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>A shallow inlining is applied bottom-up on functions that do
not recurse, and do not have the <code class="docutils literal notranslate"><span class="pre">PROTECT</span></code> attribute.</p></li>
<li><p>The loop unrolling step is performed
top-down. In this step, recursive and <code class="docutils literal notranslate"><span class="pre">PROTECT</span></code>-ed functions are inlined and branching nodes are
resolved if possible. A counter is added for every recursing function to keep track of the number
of times they have been inlined to prevent infinite looping.
This recursion limit can be adjusted via command-line flags (see <a class="reference internal" href="branching.html#recursion"><span class="std std-ref">Recursion</span></a>).</p></li>
</ol>
</div></blockquote>
</li>
<li><p><strong>Building of Branching and Quantum Logic.</strong> The previous inlining step
guarantees that the FLEQ graph has no remaining user-defined functions and
contains no cycles i.e is a directed acyclic graph (DAG). As a result, it is
possible to obtain a topological sort to the nodes of the FLEQ graph. The
branching logic is built in LLVM IR top-down and to each (initially empty) QBB,
the process assigns a list of leaf nodes that QBB is dependent on. Then,
going bottom-up, the PCOAST graph for each node and each QBB is progressively
built. This build order determines the order of the print buffer (see
<a class="reference internal" href="utils.html#printing"><span class="std std-ref">Printing</span></a>). The final assignment of QBBs to PCOAST graphs for the
evaluation call is then stored to be passed to the synthesis step later in
IQC compilation.</p></li>
</ol>
<p>The final step of the process is a clean-up phase where any remain calls to FLEQ functions are removed. This includes additional
<code class="docutils literal notranslate"><span class="pre">DataList</span></code> and <code class="docutils literal notranslate"><span class="pre">QList</span></code> intrinsics which the process attempts to resolve and replace. The process of building evaluation calls
often leaves behind unused and even ill-defined calls to these intrinsics, especially for recursing functions. This is because the
inlining step must fully insert the recursing function even when it hit the recursion guard. Once the recursion guard condition is
resolved, the FLEQ graph prunes off the unused exit, but the IR remains even if it is unused and ill-formed. A common example is
indexing into an empty <code class="docutils literal notranslate"><span class="pre">QList</span></code> when the <code class="docutils literal notranslate"><span class="pre">QList</span></code>’s size is used as the exit condition. In its current form, the clean-up phase
has no way to distinguish between these legal but ill-defined remnants of the evaluation build process, or illegal and ill-defined
uses of the <code class="docutils literal notranslate"><span class="pre">QList</span></code> or <code class="docutils literal notranslate"><span class="pre">DataList</span></code> features generated by the user. For this reason, FLEQ compilation <em>does not</em> exit when such
ill-formed cases are found but instead they are replaced by undefined behavior (as handled by core LLVM). Instead, warnings are
thrown, but by default, these warnings are suppressed. These warning can be seen by setting the command-line flag:</p>
<p><code class="docutils literal notranslate"><span class="pre">-F</span> <span class="pre">verbose-cleanup=true</span></code></p>
<p>Also, the inlining process often generates trivial branching, where an LLVM Basic Block unconditionally branches to the next Basic
Block and is the unique predecessor to that Basic Block. This is by virtue of the conditioning and aggregation of the pre- and post-
quantum sections around newly generated QBBs. By default, the clean-up process collapses this trivial branching, but this can be
stopped via the command-line flag:</p>
<p><code class="docutils literal notranslate"><span class="pre">-F</span> <span class="pre">bb-cleanup=false</span></code></p>
<p>For the advanced user, this generates a textual IR which is cluttered but can provide insight into the building of evaluation calls
useful for debugging.</p>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Intel® Quantum SDK API</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting_started/index.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dgr/index.html">Developers Guide and Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">FLEQ Guide and Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="advanced.html">Advanced topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="support.html">Support</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citations.html">Citations</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">FLEQ Guide and Reference</a><ul>
  <li><a href="advanced.html">Advanced topics</a><ul>
      <li>Previous: <a href="debugging.html" title="previous chapter">Debugging</a></li>
      <li>Next: <a href="support.html" title="next chapter">Support</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024 Intel Corporation. All Rights Reserved.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/fleq/compilation-overview.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>