.. _faq:

FAQ
===

.. contents::
   :local:
   :depth: 3

Why is the amplitude of this state not the same as my by-hand calculation?
--------------------------------------------------------------------------
The amplitude of a state may differ between the result you compute when you work
the problem by hand, algebraic solver, or other quantum computing tool chain.
Take for example, the quantum circuit:

.. figure:: img/prep1.png
    :alt: Apply a NOT gate
    :align: center
    :scale: 60%

You may be surprised to find the amplitude of this qubit is :math:`-i\ket{1}`

.. code-block:: console

    Printing amplitude register of size 2
    |0>     : (0,0)                         |1>     : (0,-1)

This is a consequence of the compiler being designed to compute in
terms of the gate set for quantum dot qubits. The decomposition of X into the
native gates gives a different, but physically equivalent, global phase than we
might write doing the math by hand (where we implicitly assume our qubits
directly support the gates in the textbook). The global phase will have no
effect on observable quantities; i.e., the probability is still guaranteed to
be computed correctly. To wit:  the only outcome of a measurement on the above
qubit is :math:`\ket{1}`.

Inspecting the corresponding line in the ``.qs`` (quantum assembly file
generated by the compiler) for the above gate shows the
instruction given is

.. code-block:: console

    qurotxy QUBIT[0], 3.141593e+00, 0.000000e+00

The :ref:`qurotxy native quantum dot gate<native>`
was applied to the 0th qubit with the parameters
:math:`\pi` and :math:`0`. The matrix elements of this gate are

.. math::

    R_{xy}\left( \theta, \phi \right) &=
        \cos\left(\frac{\theta}{2}\right)\hat{I} -
        i\sin\left(\frac{\theta}{2}\right)
        \left[\hat{X}\cos\phi + \hat{Y}\sin\phi\right] \\
   &= \begin{bmatrix}
      \cos\left(\frac{\theta}{2}\right) & -i\sin\left(\frac{\theta}{2}\right)\left[\cos\phi - i\sin\phi\right]\\
      -i\sin\left(\frac{\theta}{2}\right)\left[\cos\phi + i\sin\phi\right]  & \cos\left(\frac{\theta}{2}\right) \\
      \end{bmatrix}

and substituting in :math:`\theta = \pi` and :math:`\phi = 0`, we find

.. math::

    X = R_{xy}\left( \pi, 0 \right) &= \begin{bmatrix} 0 &-i \\
                                                      -i & 0 \\
                                      \end{bmatrix}
                                      \\
                                    &= -i \begin{bmatrix} 0 & 1 \\
                                                          1 & 0 \\
                                      \end{bmatrix}

So the :math:`-i` becomes a global phase, and will not contribute to a change in
the probability of observing a given state.

....

What to do if I'm getting the "API called with qubits that are duplicated!" error?
----------------------------------------------------------------------------------

This error is caused when the following scenario occurs:

.. code-block:: c++

   qbit a;
   qbit b;
   qbit c;

   quantum_kernel void example() {
       X(a);
       H(b);
       Y(c);
   }

   int main() {
       using namespace iqsdk;
       // Set up IQS device
       IqsConfig iqs_config;
       iqs_config.num_qubits = N;
       FullStateSimulator iqs_device(iqs_config);
       iqs_device.ready();

       example();

       std::vector<std::reference_wrapper<qbit>> qids =
           // This line will trigger the above error since qubit a is added to qids twice
           {std::ref(a); std::ref(a); std::ref(c)};
       std::vector<double> ProbabilityRegister;
       ProbabilityRegister = iqs_device.getProbabilities(qids);
   }

To resolve this issue, ensure that each qubit is added exactly once. For
example, replace the ``qids`` definition with:

.. code-block:: c++

   std::vector<std::reference_wrapper<qbit>> qids =
       {std::ref(a); std::ref(b); std::ref(c)};

....

What to do if I'm getting the "1-qubit gate X on qubit Y is not available in the platform" error?
-------------------------------------------------------------------------------------------------

This is likely caused by compiling the source code with a platform configuration
file that is incompatible with the choice of compilation flags and/or simulation
backend. One solution is to recompile the source code with ``-O1`` flag.
Alternatively, the source code can be recompiled with a different platform
configuration file.

.. _path-spec:

Where can I find the Intel Quantum SDK?
-------------------------------------------------------------------------------------------------

Depending on what system you are using the location of the |IQSDK| can vary. Throughout this document
we have refered to this location as a generalized ``<path to Intel Quantum SDK>/``. Below is
a table of common paths where the |IQSDK| can be found.

.. list-table:: Common Paths to the Intel Quantum SDK
    :widths: 33 67
    :header-rows: 1

    * - System Name
      - ``<path to Intel Quantum SDK>``
    * - Intel Developers Cloud
      - ``/opt/intel/quantum_sdk/``
    * - Docker Container
      - ``/opt/intel/quantum-sdk/latest/``

.. note::

    For convenience, consider appending the SDK path to your shell's ``$PATH``
    environment variable. The typical ``bash`` syntax for this is:

    ..

        ``export PATH=$PATH:<path to Intel Quantum SDK>``

