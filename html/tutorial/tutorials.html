<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>A Tour of GHZ examples &#8212; Intel® Quantum SDK API v1.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=45183d27"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Quantum Teleportation with FLEQ" href="qexpr-teleport.html" />
    <link rel="prev" title="Tutorials" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="a-tour-of-ghz-examples">
<span id="ghz-tutorial"></span><h1>A Tour of GHZ examples<a class="headerlink" href="#a-tour-of-ghz-examples" title="Link to this heading">¶</a></h1>
<p>This tutorial provides some basic introduction to programming quantum algorithms
and working with the <code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code> through three implementations of the
following circuit</p>
<figure class="align-center" id="before-ghz-circuit">
<a class="reference internal image-reference" href="../_images/ghz_circuit.png"><img alt="GHZ circuit" src="../_images/ghz_circuit.png" style="width: 462.0px; height: 324.0px;" />
</a>
</figure>
<p>and the accompanying classical logic. The executable will manage running
the above quantum circuit and retrieving the data in the <code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code>
to confirm the instructions are producing what is intended. This circuit
produces a
<a class="reference external" href="https://doi.org/10.1007/978-94-017-0849-4_10">Greenberger-Horne-Zeilinger (GHZ) state</a>
for 4 qubits. In other words, the qubits will be in a super-position of two
states, one with all qubits in the <span class="math notranslate nohighlight">\(\ket{0}\)</span> state and one with all qubits
in the <span class="math notranslate nohighlight">\(\ket{1}\)</span> state, and each with equal chance of being measured.</p>
<p>The source code for each implementation is available in the
<code class="docutils literal notranslate"><span class="pre">quantum_examples/</span></code> directory of the Intel® Quantum SDK.</p>
<section id="ideal-ghz">
<h2>Ideal GHZ<a class="headerlink" href="#ideal-ghz" title="Link to this heading">¶</a></h2>
<p>To begin writing the program, get access to the quantum data types and methods
by including the <code class="docutils literal notranslate"><span class="pre">quintrinsics.h</span></code> and the <code class="docutils literal notranslate"><span class="pre">quantum_full_state_simulator_backend.h</span></code> headers into the
source as shown in <a class="reference internal" href="#ideal-headers"><span class="std std-numref">Listing 2</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="ideal-headers">
<div class="code-block-caption"><span class="caption-number">Listing 2 </span><span class="caption-text">The headers required to use the quantum gates or <code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code>.</span><a class="headerlink" href="#ideal-headers" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">14</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;clang/Quantum/quintrinsics.h&gt;</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="c1">/// Quantum Runtime Library APIs</span>
<span class="linenos">17</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;quantum_full_state_simulator_backend.h&gt;</span>
</pre></div>
</div>
</div>
<p>As described in <a class="reference internal" href="../getting_started/new_algos.html#new-algos"><span class="std std-ref">Writing New Algorithms</span></a>, next declare an
array of qubits (<code class="docutils literal notranslate"><span class="pre">qbit</span></code>) in the global namespace as show in <a class="reference internal" href="#ideal-qbit"><span class="std std-numref">Listing 3</span></a></p>
<div class="literal-block-wrapper docutils container" id="ideal-qbit">
<div class="code-block-caption"><span class="caption-number">Listing 3 </span><span class="caption-text">Declaration of the <code class="docutils literal notranslate"><span class="pre">qbit</span></code> type variables in global namespace.</span><a class="headerlink" href="#ideal-qbit" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">19</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">total_qubits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="linenos">20</span><span class="n">qbit</span><span class="w"> </span><span class="n">qubit_register</span><span class="p">[</span><span class="n">total_qubits</span><span class="p">];</span>
</pre></div>
</div>
</div>
<p>Next, implement the quantum algorithm by writing the functions or classes that
contain the quantum logic. The <code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code> keyword
should be in front of each function that builds the quantum algorithm. Shown in
<a class="reference internal" href="#ideal-ghz-kernel"><span class="std std-numref">Listing 4</span></a>, all the quantum instructions are placed in a single
<code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code>. The first instruction is to initialize the state of each
qubit by utilizing a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop to call <code class="docutils literal notranslate"><span class="pre">PrepZ()</span></code> on the elements of the
<code class="docutils literal notranslate"><span class="pre">qbit</span></code> array. Next, apply a Hadamard gate (<code class="docutils literal notranslate"><span class="pre">H()</span></code>) on the first qubit to set
it into a superposition. And lastly, apply Controlled Not gates (<code class="docutils literal notranslate"><span class="pre">CNOT()</span></code>) on
pairs of qubits to create entanglement between them.</p>
<div class="literal-block-wrapper docutils container" id="ideal-ghz-kernel">
<div class="code-block-caption"><span class="caption-number">Listing 4 </span><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code> to prepare a Greenberger-Horne-Zeilinger state.</span><a class="headerlink" href="#ideal-ghz-kernel" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">22</span><span class="n">quantum_kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">ghz_total_qubits</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">23</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">total_qubits</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">24</span><span class="w">    </span><span class="n">PrepZ</span><span class="p">(</span><span class="n">qubit_register</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="linenos">25</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">26</span>
<span class="linenos">27</span><span class="w">  </span><span class="n">H</span><span class="p">(</span><span class="n">qubit_register</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="linenos">28</span>
<span class="linenos">29</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">total_qubits</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">30</span><span class="w">    </span><span class="n">CNOT</span><span class="p">(</span><span class="n">qubit_register</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">qubit_register</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>
<span class="linenos">31</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">32</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">main</span></code> function of the program, instantiate a <code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code>
object and use its <code class="docutils literal notranslate"><span class="pre">ready()</span></code> method, as shown in
<a class="reference internal" href="#ideal-ghz-main"><span class="std std-numref">Listing 5</span></a>. Do that as
described in <a class="reference internal" href="../dgr/full_state.html#full-state"><span class="std std-ref">Configuring the FullStateSimulator</span></a>, by first
creating an <code class="docutils literal notranslate"><span class="pre">IqsConfig</span></code> object, changing it to be verbose (not required), and
then using it as an argument to the <code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code> constructor. Then use
the return of the <code class="docutils literal notranslate"><span class="pre">ready()</span></code> method to trigger an early exit if something is
wrong.</p>
<div class="literal-block-wrapper docutils container" id="ideal-ghz-main">
<div class="code-block-caption"><span class="caption-number">Listing 5 </span><span class="caption-text">Setup of the FullStateSimulator. See <a class="reference internal" href="../dgr/full_state.html#full-state"><span class="std std-ref">Configuring the FullStateSimulator</span></a> for a more detailed explanation.</span><a class="headerlink" href="#ideal-ghz-main" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">34</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">35</span><span class="w">  </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">IqsConfig</span><span class="w"> </span><span class="n">settings</span><span class="p">(</span><span class="n">total_qubits</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;noiseless&quot;</span><span class="p">);</span>
<span class="linenos">36</span><span class="w">  </span><span class="n">settings</span><span class="p">.</span><span class="n">verbose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="linenos">37</span><span class="w">  </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">FullStateSimulator</span><span class="w"> </span><span class="n">quantum_8086</span><span class="p">(</span><span class="n">settings</span><span class="p">);</span>
<span class="linenos">38</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iqsdk</span><span class="o">::</span><span class="n">QRT_ERROR_SUCCESS</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">quantum_8086</span><span class="p">.</span><span class="n">ready</span><span class="p">())</span>
<span class="linenos">39</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Next, prepare the classical data structures for working with simulation data.
Create a set of <code class="docutils literal notranslate"><span class="pre">id</span></code> values to refer to the qubits of interest as shown in
<a class="reference internal" href="#ideal-ghz-qbit-ref"><span class="std std-numref">Listing 6</span></a>. This is important
because <code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables do not necessarily specify a constant physical qubit
in hardware; this mapping can be created and changed at various stages during
program execution according to the compiler optimizations.</p>
<div class="literal-block-wrapper docutils container" id="ideal-ghz-qbit-ref">
<div class="code-block-caption"><span class="caption-number">Listing 6 </span><span class="caption-text">Declare and fill a <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> with references to the elements of the <code class="docutils literal notranslate"><span class="pre">qbit</span></code> array.</span><a class="headerlink" href="#ideal-ghz-qbit-ref" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">41</span><span class="w">  </span><span class="c1">// get references to qbits</span>
<span class="linenos">42</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="n">qbit</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">qids</span><span class="p">;</span>
<span class="linenos">43</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">total_qubits</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">44</span><span class="w">    </span><span class="n">qids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">qubit_register</span><span class="p">[</span><span class="n">id</span><span class="p">]));</span>
<span class="linenos">45</span><span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>Now that the backend simulator is ready, call the <code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="ideal-ghz-run-kernel">
<div class="code-block-caption"><span class="caption-number">Listing 7 </span><span class="caption-text">Call the <code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code>.</span><a class="headerlink" href="#ideal-ghz-run-kernel" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">47</span><span class="w">  </span><span class="n">ghz_total_qubits</span><span class="p">();</span>
</pre></div>
</div>
</div>
<p>After this line during execution, the <code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code> contains the
state-vector data describing the qubits. Although there are facilities to
conveniently specify every possible state for a set of qubits, this could be an
overwhelming amount of data. Where possible, use the available constructors
described in <a class="reference internal" href="../api/index.html#api"><span class="std std-ref">API Reference</span></a> to
configure a <code class="docutils literal notranslate"><span class="pre">QssIndex</span></code> object to refer to only the states of interest and
store them in a vector. In <a class="reference internal" href="#ideal-ghz-qssindex"><span class="std std-numref">Listing 8</span></a>, two explicit strings
formatted for 4 qubits are used to specify the two states.</p>
<div class="literal-block-wrapper docutils container" id="ideal-ghz-qssindex">
<div class="code-block-caption"><span class="caption-number">Listing 8 </span><span class="caption-text">Specifying the states of interest; this will be an argument used to collect data from the simulation.</span><a class="headerlink" href="#ideal-ghz-qssindex" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">49</span><span class="w">  </span><span class="c1">// use string constructor of Quantum State Space index to choose which</span>
<span class="linenos">50</span><span class="w">  </span><span class="c1">// basis states&#39; data is retrieved</span>
<span class="linenos">51</span><span class="w">  </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">QssIndex</span><span class="w"> </span><span class="n">state_a</span><span class="p">(</span><span class="s">&quot;|0000&gt;&quot;</span><span class="p">);</span>
<span class="linenos">52</span><span class="w">  </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">QssIndex</span><span class="w"> </span><span class="n">state_b</span><span class="p">(</span><span class="s">&quot;|1111&gt;&quot;</span><span class="p">);</span>
<span class="linenos">53</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">iqsdk</span><span class="o">::</span><span class="n">QssIndex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bases</span><span class="p">;</span>
<span class="linenos">54</span><span class="w">  </span><span class="n">bases</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">state_a</span><span class="p">);</span>
<span class="linenos">55</span><span class="w">  </span><span class="n">bases</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">state_b</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>Now access the probabilities for these two states through
<code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code>’s <code class="docutils literal notranslate"><span class="pre">getProbabilities()</span></code> method. Remember that ideally
the GHZ state would only be in <span class="math notranslate nohighlight">\(\ket{0000}\)</span> or <span class="math notranslate nohighlight">\(\ket{1111}\)</span>. So for
this simulated circuit, when summing the probabilities of measuring in either
<span class="math notranslate nohighlight">\(\ket{0000}\)</span> or <span class="math notranslate nohighlight">\(\ket{1111}\)</span>, the sum should be 1.0.</p>
<div class="literal-block-wrapper docutils container" id="ideal-ghz-sim-data">
<div class="code-block-caption"><span class="caption-number">Listing 9 </span><span class="caption-text">The classical logic that checks a property of the state in the qubit register. This gets quantum results from simulation data at runtime.</span><a class="headerlink" href="#ideal-ghz-sim-data" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">57</span><span class="w">  </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">QssMap</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">probability_map</span><span class="p">;</span>
<span class="linenos">58</span><span class="w">  </span><span class="n">probability_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quantum_8086</span><span class="p">.</span><span class="n">getProbabilities</span><span class="p">(</span><span class="n">qids</span><span class="p">,</span><span class="w"> </span><span class="n">bases</span><span class="p">);</span>
<span class="linenos">59</span>
<span class="linenos">60</span><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">total_probability</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="linenos">61</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">key_value</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">probability_map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">62</span><span class="w">    </span><span class="n">total_probability</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">key_value</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="linenos">63</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">64</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Sum of probability to measure fully entangled state: &quot;</span>
<span class="linenos">65</span><span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">total_probability</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>Alternatively, display a formatted summary of the states to the console output with
<code class="docutils literal notranslate"><span class="pre">displayProbabilities()</span></code> or <code class="docutils literal notranslate"><span class="pre">displayAmplitudes()</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="ideal-ghz-display">
<div class="code-block-caption"><span class="caption-number">Listing 10 </span><span class="caption-text">Generate a quick, formatted display of the probabilities for the two states of interest printed to the console.</span><a class="headerlink" href="#ideal-ghz-display" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">66</span><span class="w">  </span><span class="n">quantum_8086</span><span class="p">.</span><span class="n">displayProbabilities</span><span class="p">(</span><span class="n">probability_map</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>This program can be compiled with the default options. Configuring the
qubit simulation in the Intel® Quantum Simulator creates a set of qubits with no
limitation on their connectivity, in other words two-qubit operations (gates)
can be applied between any pair of qubits.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$  </span>&lt;path<span class="w"> </span>to<span class="w"> </span>Intel<span class="w"> </span>Quantum<span class="w"> </span>SDK&gt;/intel-quantum-compiler<span class="w"> </span>ideal_GHZ.cpp
</pre></div>
</div>
<p>Running the executable produces a line describing each quantum instruction
because the verbose option was set to true when configuring the
<code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code>. That is followed by the line showing that
<code class="docutils literal notranslate"><span class="pre">total_probability</span></code> is equal to 1 and the summary produced by
<code class="docutils literal notranslate"><span class="pre">displayProbabilities()</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./ideal_GHZ

<span class="go">- Run noiseless simulation (verbose mode)</span>
<span class="go">Instruction #4 : ROTXY(phi = 1.5707, gamma = 1.57075)  on phys Q 0</span>
<span class="go">Instruction #5 : ROTXY(phi = 0, gamma = 3.14154)  on phys Q 0</span>
<span class="go">Instruction #6 : ROTXY(phi = 4.71229, gamma = 1.57075)  on phys Q 1</span>
<span class="go">Instruction #7 : CPHASE(gamma = 3.1415) on phys Q0 and phys Q1</span>
<span class="go">Instruction #8 : ROTXY(phi = 1.5707, gamma = 1.57075)  on phys Q 1</span>
<span class="go">Instruction #9 : ROTXY(phi = 4.71229, gamma = 1.57075)  on phys Q 2</span>
<span class="go">Instruction #10 : CPHASE(gamma = 3.1415) on phys Q1 and phys Q2</span>
<span class="go">Instruction #11 : ROTXY(phi = 1.5707, gamma = 1.57075)  on phys Q 2</span>
<span class="go">Instruction #12 : ROTXY(phi = 4.71229, gamma = 1.57075)  on phys Q 3</span>
<span class="go">Instruction #13 : CPHASE(gamma = 3.1415) on phys Q2 and phys Q3</span>
<span class="go">Instruction #14 : ROTXY(phi = 1.5707, gamma = 1.57075)  on phys Q 3</span>
<span class="go">Sum of probability to measure fully entangled state: 1</span>
<span class="go">Printing probability map of size 2</span>
<span class="go">|0000&gt;  : 0.5                           |1111&gt;  : 0.5</span>
</pre></div>
</div>
<p>The complete code is available as <code class="docutils literal notranslate"><span class="pre">ideal_GHZ.cpp</span></code> in the <code class="docutils literal notranslate"><span class="pre">quantum_examples/</span></code>
directory of the Intel® Quantum SDK.</p>
</section>
<section id="sampled-ghz">
<h2>Sampled GHZ<a class="headerlink" href="#sampled-ghz" title="Link to this heading">¶</a></h2>
<p>As discussed in <a class="reference internal" href="../dgr/programming.html#meas-full-state"><span class="std std-ref">Measurements using Simulated Quantum Backends</span></a>,
the state-vector probabilities that the above program uses are not data that
quantum hardware is capable of returning. Consider the hypothetical scenario in
which you now need to know how many times the quantum circuit must be run and
evaluated in order to find the probability with the desired numerical accuracy.
This can be done efficiently by using the simulation data.</p>
<p>Only the non-<code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code> sections of the <code class="docutils literal notranslate"><span class="pre">ideal_GHZ.cpp</span></code> program need
changed to accomplish this. This can be done by using a different <code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code>
method after calling the <code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code>, as shown in <a class="reference internal" href="#sample-ghz-getsamples"><span class="std std-numref">Listing 11</span></a></p>
<div class="literal-block-wrapper docutils container" id="sample-ghz-getsamples">
<div class="code-block-caption"><span class="caption-number">Listing 11 </span><span class="caption-text">code_samples/sample_GHZ.cpp</span><a class="headerlink" href="#sample-ghz-getsamples" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">69</span><span class="w">  </span><span class="c1">// use sampling technique to simulate the results of many runs</span>
<span class="linenos">70</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">measurement_samples</span><span class="p">;</span>
<span class="linenos">71</span><span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">total_samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>
<span class="linenos">72</span><span class="w">  </span><span class="n">measurement_samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quantum_8086</span><span class="p">.</span><span class="n">getSamples</span><span class="p">(</span><span class="n">total_samples</span><span class="p">,</span><span class="w"> </span><span class="n">qids</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>Each <code class="docutils literal notranslate"><span class="pre">std::vector&lt;bool&gt;</span></code> represents the observation of a state, each
individual value represents the outcome of that qubit as arranged in the
<code class="docutils literal notranslate"><span class="pre">qids</span></code> vector. The <code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code> has a helper method to conveniently
calculate the number of times a given state appears in an ensemble of
observations.</p>
<div class="literal-block-wrapper docutils container" id="sample-ghz-display">
<div class="code-block-caption"><span class="caption-number">Listing 12 </span><span class="caption-text">code_samples/sample_GHZ.cpp</span><a class="headerlink" href="#sample-ghz-display" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">74</span><span class="w">  </span><span class="c1">// build a distribution of states</span>
<span class="linenos">75</span><span class="w">  </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">QssMap</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">distribution</span><span class="w"> </span><span class="o">=</span>
<span class="linenos">76</span><span class="w">          </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">FullStateSimulator</span><span class="o">::</span><span class="n">samplesToHistogram</span><span class="p">(</span><span class="n">measurement_samples</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>From this <code class="docutils literal notranslate"><span class="pre">QssMap</span></code>, calculate the estimate of the probability of observing
each state.</p>
<div class="literal-block-wrapper docutils container" id="sample-ghz-classical">
<div class="code-block-caption"><span class="caption-number">Listing 13 </span><span class="caption-text">The classical logic inspecting the results of sampling many simulated measurements.</span><a class="headerlink" href="#sample-ghz-classical" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">78</span><span class="w">  </span><span class="c1">// print out the results</span>
<span class="linenos">79</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Using &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">total_samples</span>
<span class="linenos">80</span><span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; samples, the distribution of states is:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">81</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">distribution</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">82</span><span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="linenos">83</span><span class="w">    </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">total_samples</span><span class="p">;</span>
<span class="linenos">84</span>
<span class="linenos">85</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">86</span><span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>This program can be compiled with the same command as the previous program.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>&lt;path<span class="w"> </span>to<span class="w"> </span>Intel<span class="w"> </span>Quantum<span class="w"> </span>SDK&gt;/intel-quantum-compiler<span class="w"> </span>sample_GHZ.cpp
</pre></div>
</div>
<p>In addition to the same output from <code class="docutils literal notranslate"><span class="pre">ideal_GHZ.cpp</span></code>, the result
of the <code class="docutils literal notranslate"><span class="pre">samplesToHistogram()</span></code> method is also printed out:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Using 1000 samples, the distribution of states is:</span>
<span class="go">|0000&gt; : 0.496</span>
<span class="go">|1111&gt; : 0.504</span>
</pre></div>
</div>
<p>Because the <code class="docutils literal notranslate"><span class="pre">IqsConfig</span></code> used the default setting of a random seed (by not
specifying one), this simulation will produce a different sequence of samples on
subsequent executions and thus a slightly different estimate of the probability
of observing each state.</p>
<p>The complete code is available as <code class="docutils literal notranslate"><span class="pre">sample_GHZ.cpp</span></code> in the
<code class="docutils literal notranslate"><span class="pre">quantum_examples/</span></code> directory of the Intel® Quantum SDK.</p>
</section>
<section id="ghz-state-on-quantum-dot-simulator">
<h2>GHZ state on Quantum Dot Simulator<a class="headerlink" href="#ghz-state-on-quantum-dot-simulator" title="Link to this heading">¶</a></h2>
<p>It takes the change of only a few lines of code to target another backend, as
you can see by comparing <code class="docutils literal notranslate"><span class="pre">sample_GHZ.cpp</span></code> and <code class="docutils literal notranslate"><span class="pre">qd_GHZ.cpp</span></code>
(e.g. using the <code class="docutils literal notranslate"><span class="pre">diff</span></code> CLI tool). As described in <a class="reference internal" href="../dgr/qdsim.html#qdsim"><span class="std std-ref">Quantum Dot Simulator Backend</span></a>,
the Quantum Dot Simulator (<code class="docutils literal notranslate"><span class="pre">QD_Sim</span></code>) adds to the state vector simulation by
including details from the control signals that interact with quantum dot
qubits. This creates additional computational overhead compared to the
Intel® Quantum Simulator. The first change in
this program is to reduce the size of the circuit to just a pair of qubits so
the execution stays around a few seconds.</p>
<p><code class="docutils literal notranslate"><span class="pre">QD_Sim</span></code> treats running sequential <code class="docutils literal notranslate"><span class="pre">quantum_kernels</span></code> and
measurement gates differently than the Intel® Quantum Simulator (see
<a class="reference internal" href="../dgr/qdsim.html#qdsim-imp"><span class="std std-ref">Important Points on Quantum Dot Simulator</span></a>). Although some
programs could require alteration of their logic, the above program’s
<code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code> and simulator usage is compatible with either backend. To
change the qubit simulator, instead of the <code class="docutils literal notranslate"><span class="pre">IqsConfig</span></code> object switch to
a <code class="docutils literal notranslate"><span class="pre">DeviceConfig</span></code> constructed with the argument <code class="docutils literal notranslate"><span class="pre">&quot;QD_SIM&quot;</span></code> as shown in
<a class="reference internal" href="#qd-ghz-config"><span class="std std-numref">Listing 14</span></a> (note the all capitals for the argument string).</p>
<div class="literal-block-wrapper docutils container" id="qd-ghz-config">
<div class="code-block-caption"><span class="caption-number">Listing 14 </span><span class="caption-text">Configuring the <code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code> to use the Quantum Dot Simulator backend.</span><a class="headerlink" href="#qd-ghz-config" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">34</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">35</span><span class="w">  </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">DeviceConfig</span><span class="w"> </span><span class="n">qd_config</span><span class="p">(</span><span class="s">&quot;QD_SIM&quot;</span><span class="p">);</span>
<span class="linenos">36</span><span class="w">  </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">FullStateSimulator</span><span class="w"> </span><span class="n">quantum_8086</span><span class="p">(</span><span class="n">qd_config</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>With this change of backend qubit simulation, the program must now be compiled
with non-default options. The file <code class="docutils literal notranslate"><span class="pre">intel-quantum-sdk-QDSIM.json</span></code>
points to a file describing a 6-qubit linear array. Use the <code class="docutils literal notranslate"><span class="pre">-c</span></code> flag to give
the file’s location to the compiler, and specify placement and scheduling
options with <code class="docutils literal notranslate"><span class="pre">-p</span></code> and <code class="docutils literal notranslate"><span class="pre">-S</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>&lt;path<span class="w"> </span>to<span class="w"> </span>Intel<span class="w"> </span>Quantum<span class="w"> </span>SDK&gt;/intel-quantum-compiler<span class="w"> </span>-c<span class="w"> </span>&lt;path<span class="w"> </span>to<span class="w"> </span>Intel<span class="w"> </span>Quantum<span class="w"> </span>SDK&gt;/intel-quantum-sdk-QDSIM.json<span class="w"> </span>-p<span class="w"> </span>trivial<span class="w"> </span>-S<span class="w"> </span>greedy<span class="w"> </span>qd_GHZ.cpp
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">QD_Sim</span></code> produces its own output in addition to the output
explicitly designed into the behavior of the program.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./qd_GHZ.cpp

<span class="go">1688766838 time dependent evolution start time</span>
<span class="go">sweep progress: calculation point=0 0%</span>
<span class="go">sweep progress: calculation point=18199 10%</span>
<span class="go">sweep progress: calculation point=36398 20%</span>
<span class="go">sweep progress: calculation point=54597 30%</span>
<span class="go">sweep progress: calculation point=72796 40%</span>
<span class="go">sweep progress: calculation point=90994 50%</span>
<span class="go">sweep progress: calculation point=109193 60%</span>
<span class="go">sweep progress: calculation point=127392 70%</span>
<span class="go">sweep progress: calculation point=145591 80%</span>
<span class="go">sweep progress: calculation point=163790 90%</span>
<span class="go">Time evolution took 2.568378 seconds</span>
<span class="go">Fri Jul  7 14:54:01 2023</span>
<span class="go">1688766841 time dependent evolution end time</span>
<span class="go">Sum of probability to measure fully entangled state: 0.999983</span>
<span class="go">Printing probability map of size 2</span>
<span class="go">|00&gt;    : 0.4998                        |11&gt;    : 0.5002</span>

<span class="go">Using 1000 samples, the distribution of states is:</span>
<span class="go">|00&gt; : 0.519</span>
<span class="go">|11&gt; : 0.481</span>
</pre></div>
</div>
<p>The output starts with the backend’s simulation progress, followed by the
familiar output in the program’s implementation. The probabilities
reported by the <code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code> are slightly different from the exact
<span class="math notranslate nohighlight">\(0.50\)</span> because the Quantum Dot Simulator includes the simulation of the
electronics controlling the quantum dots.</p>
<p>The complete code is available as <code class="docutils literal notranslate"><span class="pre">qd_GHZ.cpp</span></code> in the <code class="docutils literal notranslate"><span class="pre">quantum_examples/</span></code>
directory of the Intel® Quantum SDK.</p>
</section>
</section>
<section id="using-release-quantum-state">
<span id="release-quantum-state-example"></span><h1>Using <code class="docutils literal notranslate"><span class="pre">release_quantum_state()</span></code><a class="headerlink" href="#using-release-quantum-state" title="Link to this heading">¶</a></h1>
<p>Using <code class="docutils literal notranslate"><span class="pre">release_quantum_state()</span></code> to indicate the intention to effectively
abandon operating on the qubits can lead to greater reduction of the total
operations when combined with <code class="docutils literal notranslate"><span class="pre">-O1</span></code> optimization. Inconsequential operations
can be removed, and in some cases this can include a measurement operation.
Consider the following sample code. The first three <code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code> blocks
build up the preparation and measurement of a state with three angles as input
parameters.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;clang/Quantum/quintrinsics.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;quantum_full_state_simulator_backend.h&gt;</span>

<span class="n">qbit</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="n">quantum_kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">PrepAll</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">PrepZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">  </span><span class="n">PrepZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="c1">//nothing special about this ansatz</span>
<span class="n">quantum_kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Ansatz_Heisenberg</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">angle0</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">angle1</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">angle2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">RX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">angle0</span><span class="p">);</span>
<span class="w">  </span><span class="n">RY</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">angle1</span><span class="p">);</span>
<span class="w">  </span><span class="n">S</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">CNOT</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">RZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">angle2</span><span class="p">);</span>
<span class="w">  </span><span class="n">CNOT</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">Sdag</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="n">quantum_kernel</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">Measure_Heisenberg</span><span class="p">(){</span>
<span class="w">  </span><span class="n">cbit</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="w">  </span><span class="n">CNOT</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">MeasX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="c1">// XX term</span>
<span class="w">  </span><span class="n">MeasZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ZZ term</span>
<span class="w">  </span><span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">MeasX</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"> </span><span class="c1">//-YY term</span>
<span class="w">  </span><span class="n">CZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">CNOT</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

<span class="w">  </span><span class="n">release_quantum_state</span><span class="p">();</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="mf">1.</span><span class="w"> </span><span class="mf">-2.</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mf">1.</span><span class="w"> </span><span class="mf">-2.</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mf">1.</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2.</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

<span class="p">}</span>
</pre></div>
</div>
<p>The next <code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code> function calls the prior three blocks. This fourth function
contains the <code class="docutils literal notranslate"><span class="pre">release_quantum_state()</span></code> call from above.
The <code class="docutils literal notranslate"><span class="pre">main()</span></code> function calls <code class="docutils literal notranslate"><span class="pre">VQE_Heisenberg()</span></code> after
setting up a <code class="docutils literal notranslate"><span class="pre">FullStateSimulator</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">quantum_kernel</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">VQE_Heisenberg</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">angle0</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">angle1</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">angle2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">PrepAll</span><span class="p">();</span>
<span class="w">  </span><span class="n">Ansatz_Heisenberg</span><span class="w"> </span><span class="p">(</span><span class="n">angle0</span><span class="p">,</span><span class="w"> </span><span class="n">angle1</span><span class="p">,</span><span class="w"> </span><span class="n">angle2</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Measure_Heisenberg</span><span class="p">();</span><span class="w">  </span><span class="c1">//note this QK will inherit the release for this function</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">  </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">IqsConfig</span><span class="w"> </span><span class="n">settings</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;noiseless&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">FullStateSimulator</span><span class="w"> </span><span class="nf">quantum_8086</span><span class="p">(</span><span class="n">settings</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iqsdk</span><span class="o">::</span><span class="n">QRT_ERROR_SUCCESS</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">quantum_8086</span><span class="p">.</span><span class="n">ready</span><span class="p">())</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">debug1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.570796</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">debug2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">debug1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">debug3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">debug2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">VQE_Heisenberg</span><span class="p">(</span><span class="n">debug1</span><span class="p">,</span><span class="w"> </span><span class="n">debug2</span><span class="p">,</span><span class="w"> </span><span class="n">debug3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If this is compiled with <code class="docutils literal notranslate"><span class="pre">-O0</span></code> flag and no optimization is performed, we
expect each of the 3 measurement operations (<code class="docutils literal notranslate"><span class="pre">MeasX</span></code>, <code class="docutils literal notranslate"><span class="pre">MeasZ</span></code>, <code class="docutils literal notranslate"><span class="pre">MeasX</span></code>) to
be called. Looking at the resulting <code class="docutils literal notranslate"><span class="pre">.qs</span></code> file confirms this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="o">.</span><span class="n">globl</span>	<span class="s2">&quot;_Z45VQE_Heisenberg(double, double, double).QBB.3.v.stub&quot;</span> <span class="o">//</span> <span class="o">--</span> <span class="n">Begin</span> <span class="n">function</span> <span class="n">_Z45VQE_Heisenberg</span><span class="p">(</span><span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">QBB</span><span class="mf">.3</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">stub</span>
	<span class="o">.</span><span class="n">type</span>	<span class="s2">&quot;_Z45VQE_Heisenberg(double, double, double).QBB.3.v.stub&quot;</span><span class="p">,</span><span class="nd">@function</span>
<span class="s2">&quot;_Z45VQE_Heisenberg(double, double, double).QBB.3.v.stub&quot;</span><span class="p">:</span> <span class="o">//</span> <span class="o">@</span><span class="s2">&quot;_Z45VQE_Heisenberg(double, double, double).QBB.3.v.stub&quot;</span>
<span class="o">//</span> <span class="o">%</span><span class="n">bb</span><span class="mf">.0</span><span class="p">:</span>                               <span class="o">//</span> <span class="o">%</span><span class="n">aqcc</span><span class="o">.</span><span class="n">quantum</span>
	<span class="n">quprep</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
	<span class="n">quprep</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nd">@shared_variable_array</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nd">@shared_variable_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nd">@shared_variable_array</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="nd">@shared_variable_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotz</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.570796e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">4.712389e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qucphase</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">3.141593e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">1.570796e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotz</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nd">@shared_variable_array</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">4.712389e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qucphase</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">3.141593e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">1.570796e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotz</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">4.712389e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">4.712389e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qucphase</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">3.141593e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">1.570796e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">4.712389e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="hll">	<span class="n">qumeasz</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="nd">@shared_cbit_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span>	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">1.570796e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="hll">	<span class="n">qumeasz</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="nd">@shared_cbit_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span>	<span class="n">qucphase</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">3.141593e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">4.712389e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="hll">	<span class="n">qumeasz</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="nd">@shared_cbit_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span>	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">1.570796e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qucphase</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">3.141593e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">4.712389e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qucphase</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">3.141593e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">1.570796e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
	<span class="k">return</span>
<span class="o">.</span><span class="n">Lfunc_end3</span><span class="p">:</span>
	<span class="o">.</span><span class="n">size</span>	<span class="s2">&quot;_Z45VQE_Heisenberg(double, double, double).QBB.3.v.stub&quot;</span><span class="p">,</span> <span class="o">.</span><span class="n">Lfunc_end3</span><span class="o">-</span><span class="s2">&quot;_Z45VQE_Heisenberg(double, double, double).QBB.3.v.stub&quot;</span>
                                        <span class="o">//</span> <span class="o">--</span> <span class="n">End</span> <span class="n">function</span>
	<span class="o">.</span><span class="n">section</span>	<span class="s2">&quot;.note.GNU-stack&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="nd">@progbits</span>
</pre></div>
</div>
<p>However, compiling with <code class="docutils literal notranslate"><span class="pre">-O1</span></code> will cause the optimizer to remove operations.
Here in addition to combining and removing gates, the optimizer will remove a
measurement operation because its outcome can be deduced from the other two
measurements’ outcomes. The <code class="docutils literal notranslate"><span class="pre">cbit</span></code> used to store the now-missing measurement
outcome will have its value correctly set by the Quantum Runtime.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="o">.</span><span class="n">globl</span>	<span class="s2">&quot;_Z45VQE_Heisenberg(double, double, double).QBB.3.v.stub&quot;</span> <span class="o">//</span> <span class="o">--</span> <span class="n">Begin</span> <span class="n">function</span> <span class="n">_Z45VQE_Heisenberg</span><span class="p">(</span><span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="p">,</span> <span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">QBB</span><span class="mf">.3</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">stub</span>
	<span class="o">.</span><span class="n">type</span>	<span class="s2">&quot;_Z45VQE_Heisenberg(double, double, double).QBB.3.v.stub&quot;</span><span class="p">,</span><span class="nd">@function</span>
<span class="s2">&quot;_Z45VQE_Heisenberg(double, double, double).QBB.3.v.stub&quot;</span><span class="p">:</span> <span class="o">//</span> <span class="o">@</span><span class="s2">&quot;_Z45VQE_Heisenberg(double, double, double).QBB.3.v.stub&quot;</span>
<span class="o">//</span> <span class="o">%</span><span class="n">bb</span><span class="mf">.0</span><span class="p">:</span>                               <span class="o">//</span> <span class="o">%</span><span class="n">aqcc</span><span class="o">.</span><span class="n">quantum</span>
	<span class="n">quprep</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
	<span class="n">quprep</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nd">@shared_variable_array</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nd">@shared_variable_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nd">@shared_variable_array</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="nd">@shared_variable_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">4.712389e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">0.000000e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qucphase</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">3.141593e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">0.000000e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="hll">	<span class="n">qumeasz</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="nd">@shared_cbit_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span>	<span class="n">qurotxy</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.570796e+00</span><span class="p">,</span> <span class="mf">4.712389e+00</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="hll">	<span class="n">qumeasz</span> <span class="n">QUBIT</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="nd">@shared_cbit_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="n">slice_idx</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</span>	<span class="k">return</span>
<span class="o">.</span><span class="n">Lfunc_end3</span><span class="p">:</span>
	<span class="o">.</span><span class="n">size</span>	<span class="s2">&quot;_Z45VQE_Heisenberg(double, double, double).QBB.3.v.stub&quot;</span><span class="p">,</span> <span class="o">.</span><span class="n">Lfunc_end3</span><span class="o">-</span><span class="s2">&quot;_Z45VQE_Heisenberg(double, double, double).QBB.3.v.stub&quot;</span>
                                        <span class="o">//</span> <span class="o">--</span> <span class="n">End</span> <span class="n">function</span>
	<span class="o">.</span><span class="n">section</span>	<span class="s2">&quot;.note.GNU-stack&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="nd">@progbits</span>
</pre></div>
</div>
</section>
<section id="writing-variational-algorithms">
<h1>Writing Variational Algorithms<a class="headerlink" href="#writing-variational-algorithms" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Variational algorithms are considered to be one of the most promising
applications to allow quantum advantage using near-term systems <span id="id2">[<a class="reference internal" href="../citations.html#id25" title="Marco Cerezo, Andrew Arrasmith, Ryan Babbush, Simon C Benjamin, Suguru Endo, Keisuke Fujii, Jarrod R McClean, Kosuke Mitarai, Xiao Yuan, Lukasz Cincio, and others. Variational quantum algorithms. Nature Reviews Physics, 3(9):625–644, 2021. doi:10.1038/s42254-021-00348-9.">CAB+21</a>]</span>.
The Intel® Quantum SDK has many features that are geared for coding variational
algorithms with a focus on performance. The Hybrid Quantum Classical
Library (HQCL) <span id="id3">[<a class="reference internal" href="../citations.html#id26" title="Intel Labs. Hybrid quantum-classical library. GitHub repository, 2023. Accessed on: 2023-03-26. URL: https://github.com/IntelLabs/Hybrid-Quantum-Classical-Library.">IntelLabs23</a>]</span> is a collection of tools that will help a user
increase productivity when programming variational algorithms. This example
combines these tools with <code class="docutils literal notranslate"><span class="pre">dlib</span></code> (a popular C++ library for solving
optimization problems <span id="id4">[<a class="reference internal" href="../citations.html#id27" title="dlib: a toolkit for making real world machine learning and data analysis applications in C++. Website, 2023. Accessed: 2023-03-26. URL: http://dlib.net/.">DLI23</a>]</span> ), to applying the variational algorithm to
the generation of thermofield double (TFD) states <span id="id5">[<a class="reference internal" href="../citations.html#id28" title="Shavindra P. Premaratne and A. Y. Matsuura. Engineering a cost function for real-world implementation of a variational quantum algorithm. In 2020 IEEE International Conference on Quantum Computing and Engineering (QCE), volume, 278-285. 2020. doi:10.1109/QCE49297.2020.00042.">PM20</a>]</span> <span id="id6">[<a class="reference internal" href="../citations.html#id29" title="R Sagastizabal, SP Premaratne, BA Klaver, MA Rol, V Negîrneac, MS Moreira, X Zou, S Johri, N Muthusubramanian, M Beekman, and others. Variational preparation of finite-temperature states on a quantum computer. npj Quantum Information, 7(1):130, 2021. doi:10.1038/s41534-021-00468-1.">SPK+21</a>]</span>.
Previous implementations <span id="id7">[<a class="reference internal" href="../citations.html#id10" title="Pradnya Khalate, Xin-Chuan Wu, Shavindra Premaratne, Justin Hogaboam, Adam Holmes, Albert Schmitz, Gian Giacomo Guerreschi, Xiang Zou, and A. Y. Matsuura. An LLVM-based C++ compiler toolchain for variational hybrid quantum-classical algorithms and quantum accelerators. 2022. arXiv:2202.11142.">KWP+22</a>]</span> included the latter workload with a
hard-coded version of the cost function expression, which was pre-calculated.
<a class="reference internal" href="#ansatz"><span class="std std-numref">Fig. 1</span></a> (reproduced from <span id="id8">[<a class="reference internal" href="../citations.html#id10" title="Pradnya Khalate, Xin-Chuan Wu, Shavindra Premaratne, Justin Hogaboam, Adam Holmes, Albert Schmitz, Gian Giacomo Guerreschi, Xiang Zou, and A. Y. Matsuura. An LLVM-based C++ compiler toolchain for variational hybrid quantum-classical algorithms and quantum accelerators. 2022. arXiv:2202.11142.">KWP+22</a>]</span>) shows the full circuit that is
used for the variational algorithm execution.</p>
<figure class="align-default" id="ansatz">
<a class="reference internal image-reference" href="../_images/tfd_ansatz.png"><img alt="../_images/tfd_ansatz.png" src="../_images/tfd_ansatz.png" style="width: 75%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 1 </span><span class="caption-text">The quantum circuit for single-step TFD state generation. Stages:(I) preparing infinite temperature TFD state, (II) Intra-system <span class="math notranslate nohighlight">\(R_X\)</span> operation, (III) Intra-system <span class="math notranslate nohighlight">\(ZZ\)</span> operation, (IV) Inter-system <span class="math notranslate nohighlight">\(XX\)</span> operation, (V) Inter-system <span class="math notranslate nohighlight">\(ZZ\)</span> operation. A and B represent the two subsystems, each containing <span class="math notranslate nohighlight">\(N_\textrm{sub}\)</span> qubits. (reproduced from <span id="id9">[<a class="reference internal" href="../citations.html#id10" title="Pradnya Khalate, Xin-Chuan Wu, Shavindra Premaratne, Justin Hogaboam, Adam Holmes, Albert Schmitz, Gian Giacomo Guerreschi, Xiang Zou, and A. Y. Matsuura. An LLVM-based C++ compiler toolchain for variational hybrid quantum-classical algorithms and quantum accelerators. 2022. arXiv:2202.11142.">KWP+22</a>]</span>)</span><a class="headerlink" href="#ansatz" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In this implementation, HQCL will symbolically construct the cost function
expression, and use qubit-wise commutation (QWC) <span id="id10">[<a class="reference internal" href="../citations.html#id30" title="Tzu-Ching Yen, Vladyslav Verteletskyi, and Artur F. Izmaylov. Measuring all compatible operators in one series of single-qubit measurements using unitary transformations. Journal of Chemical Theory and Computation, 16(4):2400-2409, 2020. PMID: 32150412. doi:10.1021/acs.jctc.0c00008.">YVI20</a>]</span> to
group terms and reduce the number of circuit repetitions required to calculate
the cost function. HQCL will also automatically populate the necessary mapping
angles at runtime, to facilitate measurements of the system along different
axes.</p>
<p>The classical optimization in this workload will be handled using the <code class="docutils literal notranslate"><span class="pre">dlib</span></code>
C++
library. The <code class="docutils literal notranslate"><span class="pre">dlib</span></code> library contains powerful functions performing local as
well
as global optimizations. Here, the <code class="docutils literal notranslate"><span class="pre">find_min_bobyqa</span></code> function for the
minimization of the cost function performs quite well for the chosen workload.
The choice of the optimization technique can heavily influence the number of
iterations required for convergence of certain variational algorithms. The
Intel Quantum Simulator <span id="id11">[<a class="reference internal" href="../citations.html#id21" title="Gian Giacomo Guerreschi, Justin Hogaboam, Fabio Baruffa, and Nicolas P D Sawaya. Intel quantum simulator: a cloud-ready high-performance simulator of quantum circuits. Quantum Science and Technology, 5(3):034007, may 2020. doi:10.1088/2058-9565/ab8505.">GHBS20</a>]</span> will be used as the backend in this
example.</p>
</section>
<section id="code">
<h2>Code<a class="headerlink" href="#code" title="Link to this heading">¶</a></h2>
<section id="preamble">
<h3>Preamble<a class="headerlink" href="#preamble" title="Link to this heading">¶</a></h3>
<p>In the preamble of the source file shown in <a class="reference internal" href="#tfd-head"><span class="std std-numref">Listing 15</span></a> below, the
header files for the
IQSDK, <code class="docutils literal notranslate"><span class="pre">dlib</span></code>, and HQCL are included first.</p>
<div class="literal-block-wrapper docutils container" id="tfd-head">
<div class="code-block-caption"><span class="caption-number">Listing 15 </span><span class="caption-text">The preamble of the source file.</span><a class="headerlink" href="#tfd-head" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// Intel Quantum SDK header files</span>
<span class="linenos"> 2</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;clang/Quantum/quintrinsics.h&gt;</span>
<span class="linenos"> 3</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;quantum.hpp&gt;</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="linenos"> 6</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="c1">// Library for optimizations</span>
<span class="linenos"> 9</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;dlib/optimization.h&gt;</span>
<span class="linenos">10</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;dlib/global_optimization.h&gt;</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="c1">// Libraries for automating hybrid algorithm</span>
<span class="linenos">13</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;armadillo&gt;</span>
<span class="linenos">14</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;SymbolicOperator.hpp&quot;</span>
<span class="linenos">15</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;SymbolicOperatorUtils.hpp&quot;</span>
<span class="linenos">16</span>
<span class="linenos">17</span><span class="c1">// Define the number of qubits needed for compilation</span>
<span class="linenos">18</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N_sub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="c1">// Number of qubits in subsystem (thermal state size)</span>
<span class="linenos">19</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N_ss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// Number of subsystems (Not a general parameter to be changed)</span>
<span class="linenos">20</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N_ss</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="c1">// Total number of qubits (TFD state size)</span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="n">qbit</span><span class="w"> </span><span class="n">QReg</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="linenos">23</span><span class="n">cbit</span><span class="w"> </span><span class="n">CReg</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="linenos">24</span>
<span class="linenos">25</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N_var_angles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="linenos">26</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N_map_angles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="linenos">27</span>
<span class="linenos">28</span><span class="kt">double</span><span class="w"> </span><span class="n">QVarParams</span><span class="p">[</span><span class="n">N_var_angles</span><span class="p">];</span><span class="w"> </span><span class="c1">// Array to hold dynamic parameters for quantum algorithm</span>
<span class="linenos">29</span><span class="kt">double</span><span class="w"> </span><span class="n">QMapParams</span><span class="p">[</span><span class="n">N_map_angles</span><span class="p">];</span><span class="w"> </span><span class="c1">// Array to hold mapping parameters for HQCL</span>
<span class="linenos">30</span>
<span class="linenos">31</span><span class="k">typedef</span><span class="w"> </span><span class="n">dlib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">N_var_angles</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">column_vector</span><span class="p">;</span>
<span class="linenos">32</span><span class="k">namespace</span><span class="w"> </span><span class="nn">hqcl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">hybrid</span><span class="o">::</span><span class="nn">quantum</span><span class="o">::</span><span class="nn">core</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>A data structure within <code class="docutils literal notranslate"><span class="pre">dlib</span></code> is defined (using a <code class="docutils literal notranslate"><span class="pre">typedef</span></code>) in line 31
for convenience in passing the set of parameters into the optimization loop.
This algorithm will use four variational parameters and two
mapping angles per qubit (a total of eight).</p>
</section>
<section id="construction-of-the-ansatz">
<h3>Construction of the Ansatz<a class="headerlink" href="#construction-of-the-ansatz" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="#tfd-terms"><span class="std std-numref">Listing 16</span></a> contains the operations corresponding to the stages II,
III, IV, and V from <a class="reference internal" href="#ansatz"><span class="std std-numref">Fig. 1</span></a> (stage I will be discussed later in
<a class="reference internal" href="#tfd-aux-qkernels"><span class="std std-numref">Listing 17</span></a>). These are the four core stages that define the operations for the
TFD algorithm. A future version of the IQSDK will support <code class="docutils literal notranslate"><span class="pre">quantum</span> <span class="pre">kernel</span>
<span class="pre">expressions</span></code> which can be used to conveniently construct quantum kernels in a
modular way <span id="id12">[<a class="reference internal" href="../citations.html#id32" title="Jennifer Paykin, Albert T. Schmitz, and A. Y. Matsuura. A functional approach to the modular construction of quantum logic: part i. In APS March Meeting Abstracts, volume 2023, RR08–007. 2023. URL: https://meetings.aps.org/Meeting/MAR23/Session/RR08.7.">PSM23</a>]</span> <span id="id13">[<a class="reference internal" href="../citations.html#id33" title="Albert Schmitz. A functional approach to the modular construction of quantum logic: part ii. In APS March Meeting Abstracts, volume 2023, RR08–008. 2023. URL: https://meetings.aps.org/Meeting/MAR23/Session/RR08.8.">Sch23</a>]</span>.</p>
<div class="literal-block-wrapper docutils container" id="tfd-terms">
<div class="code-block-caption"><span class="caption-number">Listing 16 </span><span class="caption-text">The core set of operations to implement the TFD algorithm.</span><a class="headerlink" href="#tfd-terms" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">34</span><span class="n">quantum_kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">TFD_terms</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">35</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">index_intraX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">index_interX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">index_interZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">36</span>
<span class="linenos">37</span><span class="w">  </span><span class="c1">// Single qubit variational terms</span>
<span class="linenos">38</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_intraX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraX</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraX</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">39</span><span class="w">    </span><span class="n">RX</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">index_intraX</span><span class="p">],</span><span class="w"> </span><span class="n">QVarParams</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="linenos">40</span>
<span class="linenos">41</span><span class="w">  </span><span class="c1">// Two-qubit intra-system variational terms (adjacent)</span>
<span class="linenos">42</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">grand_intraZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">grand_intraZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">grand_intraZ</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">43</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_ss</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">44</span><span class="w">      </span><span class="n">CNOT</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">grand_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">QReg</span><span class="p">[</span><span class="n">grand_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="p">]);</span>
<span class="linenos">45</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_ss</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">46</span><span class="w">      </span><span class="n">RZ</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">grand_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="p">],</span><span class="w"> </span><span class="n">QVarParams</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="linenos">47</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_ss</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">48</span><span class="w">      </span><span class="n">CNOT</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">grand_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">QReg</span><span class="p">[</span><span class="n">grand_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="p">]);</span>
<span class="linenos">49</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">50</span>
<span class="linenos">51</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">N_sub</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">52</span><span class="w">    </span><span class="c1">// Two-qubit intra-system variational terms (boundary term)</span>
<span class="linenos">53</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_ss</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">54</span><span class="w">      </span><span class="n">CNOT</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="p">],</span><span class="w"> </span><span class="n">QReg</span><span class="p">[</span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">N_sub</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)]);</span>
<span class="linenos">55</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_ss</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">56</span><span class="w">      </span><span class="n">RZ</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">N_sub</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)],</span><span class="w"> </span><span class="n">QVarParams</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="linenos">57</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_ss</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">58</span><span class="w">      </span><span class="n">CNOT</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="p">],</span><span class="w"> </span><span class="n">QReg</span><span class="p">[</span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">N_sub</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)]);</span>
<span class="linenos">59</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">60</span>
<span class="linenos">61</span><span class="w">  </span><span class="c1">// two-qubit inter-system XX variational terms</span>
<span class="linenos">62</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_interX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_interX</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="n">index_interX</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">63</span><span class="w">    </span><span class="n">RY</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interX</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="p">],</span><span class="w"> </span><span class="o">-</span><span class="n">M_PI_2</span><span class="p">);</span>
<span class="linenos">64</span><span class="w">    </span><span class="n">RY</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interX</span><span class="p">],</span><span class="w"> </span><span class="o">-</span><span class="n">M_PI_2</span><span class="p">);</span>
<span class="linenos">65</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">66</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_interX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_interX</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="n">index_interX</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">67</span><span class="w">    </span><span class="n">CNOT</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interX</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="p">],</span><span class="w"> </span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interX</span><span class="p">]);</span>
<span class="linenos">68</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_interX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_interX</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="n">index_interX</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">69</span><span class="w">    </span><span class="n">RZ</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interX</span><span class="p">],</span><span class="w"> </span><span class="n">QVarParams</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="linenos">70</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_interX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_interX</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="n">index_interX</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">71</span><span class="w">    </span><span class="n">CNOT</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interX</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="p">],</span><span class="w"> </span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interX</span><span class="p">]);</span>
<span class="linenos">72</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_interX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_interX</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="n">index_interX</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">73</span><span class="w">    </span><span class="n">RY</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interX</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="p">],</span><span class="w"> </span><span class="n">M_PI_2</span><span class="p">);</span>
<span class="linenos">74</span><span class="w">    </span><span class="n">RY</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interX</span><span class="p">],</span><span class="w"> </span><span class="n">M_PI_2</span><span class="p">);</span>
<span class="linenos">75</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">76</span>
<span class="linenos">77</span><span class="w">  </span><span class="c1">// two-qubit inter-system ZZ variational terms</span>
<span class="linenos">78</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_interZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_interZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="n">index_interZ</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">79</span><span class="w">    </span><span class="n">CNOT</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interZ</span><span class="p">],</span><span class="w"> </span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="p">]);</span>
<span class="linenos">80</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_interZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_interZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="n">index_interZ</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">81</span><span class="w">    </span><span class="n">RZ</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="p">],</span><span class="w"> </span><span class="n">QVarParams</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="linenos">82</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index_interZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_interZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="n">index_interZ</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">83</span><span class="w">    </span><span class="n">CNOT</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interZ</span><span class="p">],</span><span class="w"> </span><span class="n">QReg</span><span class="p">[</span><span class="n">index_interZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="p">]);</span>
</pre></div>
</div>
</div>
<p>There are three supporting quantum kernels that are used (see
<a class="reference internal" href="#tfd-aux-qkernels"><span class="std std-numref">Listing 17</span></a>), in
addition to the core set of operations. <code class="docutils literal notranslate"><span class="pre">PrepZAll()</span></code> is used to prepare all
the qubits in the ground state at the beginning of every iteration.
<code class="docutils literal notranslate"><span class="pre">BellPrep()</span></code> is used to prepare Bell pairs between corresponding qubits
of the two subsystems, effectively resulting in the infinite temperature
TFD state. The <code class="docutils literal notranslate"><span class="pre">DynamicMapping()</span></code> quantum kernel is used to hold the mapping
operations that HQCL will implement for basis changes during runtime.</p>
<div class="literal-block-wrapper docutils container" id="tfd-aux-qkernels">
<div class="code-block-caption"><span class="caption-number">Listing 17 </span><span class="caption-text">The supporting quantum kernels to implement the TFD algorithm.</span><a class="headerlink" href="#tfd-aux-qkernels" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 86</span><span class="n">quantum_kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">PrepZAll</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 87</span><span class="w">  </span><span class="c1">// initialize the qubits</span>
<span class="linenos"> 88</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">Index</span><span class="o">++</span><span class="p">)</span>
<span class="linenos"> 89</span><span class="w">    </span><span class="n">PrepZ</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">Index</span><span class="p">]);</span>
<span class="linenos"> 90</span><span class="p">}</span>
<span class="linenos"> 91</span>
<span class="linenos"> 92</span><span class="n">quantum_kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">BellPrep</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 93</span><span class="w">  </span><span class="c1">// prepare the Bell pairs (T -&gt; Infinity)</span>
<span class="linenos"> 94</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="n">Index</span><span class="o">++</span><span class="p">)</span>
<span class="linenos"> 95</span><span class="w">    </span><span class="n">H</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">Index</span><span class="p">]);</span>
<span class="linenos"> 96</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="n">Index</span><span class="o">++</span><span class="p">)</span>
<span class="linenos"> 97</span><span class="w">    </span><span class="n">CNOT</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">Index</span><span class="p">],</span><span class="w"> </span><span class="n">QReg</span><span class="p">[</span><span class="n">Index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="p">]);</span>
<span class="linenos"> 98</span><span class="p">}</span>
<span class="linenos"> 99</span>
<span class="linenos">100</span><span class="n">quantum_kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">DynamicMapping</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">101</span><span class="w">  </span><span class="c1">// Not part of the ansatz</span>
<span class="linenos">102</span><span class="w">  </span><span class="c1">// Rotations to map X to Z or Y to Z</span>
<span class="linenos">103</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">qubit_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">qubit_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">qubit_index</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">104</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">map_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">qubit_index</span><span class="p">;</span>
<span class="linenos">105</span><span class="w">    </span><span class="n">RY</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">qubit_index</span><span class="p">],</span><span class="w"> </span><span class="n">QMapParams</span><span class="p">[</span><span class="n">map_index</span><span class="p">]);</span>
<span class="linenos">106</span><span class="w">    </span><span class="n">RX</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">qubit_index</span><span class="p">],</span><span class="w"> </span><span class="n">QMapParams</span><span class="p">[</span><span class="n">map_index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>
<span class="linenos">107</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">108</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>The supporting quantum kernels (<a class="reference internal" href="#tfd-aux-qkernels"><span class="std std-numref">Listing 17</span></a>) and the core TFD
quantum kernel
(<a class="reference internal" href="#tfd-terms"><span class="std std-numref">Listing 16</span></a>) are combined to form the full quantum circuit in
<a class="reference internal" href="#tfd-full"><span class="std std-numref">Listing 18</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="tfd-full">
<div class="code-block-caption"><span class="caption-number">Listing 18 </span><span class="caption-text">The full TFD quantum kernel to run during optimization loop.</span><a class="headerlink" href="#tfd-full" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">110</span><span class="n">quantum_kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">TFD_full</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">111</span><span class="w">  </span><span class="n">PrepZAll</span><span class="p">();</span>
<span class="linenos">112</span><span class="w">  </span><span class="n">BellPrep</span><span class="p">();</span>
<span class="linenos">113</span><span class="w">  </span><span class="n">TFD_terms</span><span class="p">();</span>
<span class="linenos">114</span><span class="w">  </span><span class="n">DynamicMapping</span><span class="p">();</span>
<span class="linenos">115</span><span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="functions-for-constructing-the-cost-expression-and-the-cost-calculation">
<h3>Functions for Constructing the Cost Expression and the Cost Calculation<a class="headerlink" href="#functions-for-constructing-the-cost-expression-and-the-cost-calculation" title="Link to this heading">¶</a></h3>
<div class="literal-block-wrapper docutils container" id="tfd-constructfullsymbop">
<div class="code-block-caption"><span class="caption-number">Listing 19 </span><span class="caption-text">Construction of the full symbolic operator for the cost function expression.</span><a class="headerlink" href="#tfd-constructfullsymbop" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">117</span><span class="n">hqcl</span><span class="o">::</span><span class="n">SymbolicOperator</span><span class="w"> </span><span class="nf">constructFullSymbOp</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">inv_temp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">118</span><span class="w">  </span><span class="n">hqcl</span><span class="o">::</span><span class="n">SymbolicOperator</span><span class="w"> </span><span class="n">symb_op</span><span class="p">;</span>
<span class="linenos">119</span><span class="w">  </span><span class="n">hqcl</span><span class="o">::</span><span class="n">pstring</span><span class="w"> </span><span class="n">sym_term</span><span class="p">;</span>
<span class="linenos">120</span>
<span class="linenos">121</span><span class="w">  </span><span class="c1">// Single qubit variational terms</span>
<span class="linenos">122</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index_intraX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraX</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraX</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">123</span><span class="w">      </span><span class="n">sym_term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">index_intraX</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;X&#39;</span><span class="p">)};</span>
<span class="linenos">124</span><span class="w">      </span><span class="n">symb_op</span><span class="p">.</span><span class="n">addTerm</span><span class="p">(</span><span class="n">sym_term</span><span class="p">,</span><span class="w"> </span><span class="mf">1.00</span><span class="p">);</span>
<span class="linenos">125</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">126</span>
<span class="linenos">127</span><span class="w">  </span><span class="c1">// Two-qubit intra-system variational terms (adjacent)</span>
<span class="linenos">128</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">grand_intraZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">grand_intraZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">grand_intraZ</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">129</span><span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_ss</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">130</span><span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">qIndex0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grand_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="p">;</span>
<span class="linenos">131</span><span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">qIndex1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grand_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="linenos">132</span><span class="w">          </span><span class="n">sym_term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">qIndex0</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;Z&#39;</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">qIndex1</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;Z&#39;</span><span class="p">)};</span>
<span class="linenos">133</span><span class="w">          </span><span class="n">symb_op</span><span class="p">.</span><span class="n">addTerm</span><span class="p">(</span><span class="n">sym_term</span><span class="p">,</span><span class="w"> </span><span class="mf">1.00</span><span class="p">);</span>
<span class="linenos">134</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">135</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">136</span>
<span class="linenos">137</span><span class="w">  </span><span class="c1">// Two-qubit intra-system variational terms (boundary term)</span>
<span class="linenos">138</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">N_sub</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">139</span><span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_ss</span><span class="p">;</span><span class="w"> </span><span class="n">index_intraZ</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">140</span><span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">qIndex0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="p">;</span>
<span class="linenos">141</span><span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">qIndex1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N_sub</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index_intraZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">N_sub</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="linenos">142</span><span class="w">          </span><span class="n">sym_term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">qIndex0</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;Z&#39;</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">qIndex1</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;Z&#39;</span><span class="p">)};</span>
<span class="linenos">143</span><span class="w">          </span><span class="n">symb_op</span><span class="p">.</span><span class="n">addTerm</span><span class="p">(</span><span class="n">sym_term</span><span class="p">,</span><span class="w"> </span><span class="mf">1.00</span><span class="p">);</span>
<span class="linenos">144</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">145</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">146</span>
<span class="linenos">147</span><span class="w">  </span><span class="c1">// two-qubit inter-system XX variational terms</span>
<span class="linenos">148</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index_interX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_interX</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="n">index_interX</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">149</span><span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">qIndex0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index_interX</span><span class="p">;</span>
<span class="linenos">150</span><span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">qIndex1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index_interX</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span>
<span class="linenos">151</span><span class="w">      </span><span class="n">sym_term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">qIndex0</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;X&#39;</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">qIndex1</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;X&#39;</span><span class="p">)};</span>
<span class="linenos">152</span><span class="w">      </span><span class="n">symb_op</span><span class="p">.</span><span class="n">addTerm</span><span class="p">(</span><span class="n">sym_term</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">pow</span><span class="p">(</span><span class="n">inv_temp</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.00</span><span class="p">));</span>
<span class="linenos">153</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">154</span>
<span class="linenos">155</span><span class="w">  </span><span class="c1">// two-qubit inter-system XX variational terms</span>
<span class="linenos">156</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index_interZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">index_interZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span><span class="w"> </span><span class="n">index_interZ</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">157</span><span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">qIndex0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index_interZ</span><span class="p">;</span>
<span class="linenos">158</span><span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">qIndex1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index_interZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N_sub</span><span class="p">;</span>
<span class="linenos">159</span><span class="w">      </span><span class="n">sym_term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">qIndex0</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;Z&#39;</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">qIndex1</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;Z&#39;</span><span class="p">)};</span>
<span class="linenos">160</span><span class="w">      </span><span class="n">symb_op</span><span class="p">.</span><span class="n">addTerm</span><span class="p">(</span><span class="n">sym_term</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">pow</span><span class="p">(</span><span class="n">inv_temp</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.00</span><span class="p">));</span>
<span class="linenos">161</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">162</span>
<span class="linenos">163</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">symb_op</span><span class="p">;</span>
<span class="linenos">164</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>Programmatic construction of the cost expression is necessary for HQCL to form
the QWC groups, to generate the necessary circuits to run per optimization
iteration, and to correctly evaluate the cost at each iteration. In
<a class="reference internal" href="#tfd-constructfullsymbop"><span class="std std-numref">Listing 19</span></a>, we generate symbolic terms (<code class="docutils literal notranslate"><span class="pre">sym_term</span></code>) for
every expression
present, and add it to the full symbolic operator <code class="docutils literal notranslate"><span class="pre">symb_op</span></code>. The full cost
expression to be coded is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}C(\beta) &amp;= \sum_{i=1}^{N_\textrm{sub}} {X_i^A} +\sum_{i=1}^{N_\textrm{sub}} {X_i^B} + \sum_{i=1}^{N_\textrm{sub}} {Z_i^A Z_{i+1}^A} + \sum_{i=1}^{N_\textrm{sub}} {Z_i^B Z_{i+1}^B} \\
         &amp;- \beta^{-1} \left( \sum_{i=1}^{N_\textrm{sub}} {X_i^A X_i^B} + \sum_{i=1}^{N_\textrm{sub}} {Z_i^A Z_i^B} \right)\end{split}\]</div>
<p>where the subscript represents the qubit index and the superscript represents
the subsystem the qubit belongs to (A or B) <span id="id14">[<a class="reference internal" href="../citations.html#id10" title="Pradnya Khalate, Xin-Chuan Wu, Shavindra Premaratne, Justin Hogaboam, Adam Holmes, Albert Schmitz, Gian Giacomo Guerreschi, Xiang Zou, and A. Y. Matsuura. An LLVM-based C++ compiler toolchain for variational hybrid quantum-classical algorithms and quantum accelerators. 2022. arXiv:2202.11142.">KWP+22</a>]</span>.</p>
<div class="literal-block-wrapper docutils container" id="tfd-run-qkernel">
<div class="code-block-caption"><span class="caption-number">Listing 20 </span><span class="caption-text">A function to calculate the cost at each iteration during optimization.</span><a class="headerlink" href="#tfd-run-qkernel" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">166</span><span class="kt">double</span><span class="w"> </span><span class="nf">runQuantumKernel</span><span class="p">(</span><span class="n">iqsdk</span><span class="o">::</span><span class="n">FullStateSimulator</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sim_device</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">column_vector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">params</span><span class="p">,</span>
<span class="linenos">167</span><span class="w">                   </span><span class="n">hqcl</span><span class="o">::</span><span class="n">SymbolicOperator</span><span class="w"> </span><span class="o">&amp;</span><span class="n">symb_op</span><span class="p">,</span><span class="w"> </span><span class="n">hqcl</span><span class="o">::</span><span class="n">QWCMap</span><span class="w"> </span><span class="o">&amp;</span><span class="n">qwc_groups</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">168</span><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">total_cost</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="linenos">169</span>
<span class="linenos">170</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">qwc_group</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">qwc_groups</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">171</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">variable_params</span><span class="p">;</span>
<span class="linenos">172</span><span class="w">    </span><span class="n">variable_params</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="linenos">173</span>
<span class="linenos">174</span><span class="w">    </span><span class="n">hqcl</span><span class="o">::</span><span class="n">SymbolicOperatorUtils</span><span class="o">::</span><span class="n">applyBasisChange</span><span class="p">(</span><span class="n">qwc_group</span><span class="p">.</span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="n">variable_params</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="linenos">175</span>
<span class="linenos">176</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="n">qbit</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">qids</span><span class="p">;</span>
<span class="linenos">177</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">qubit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">qubit</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">qubit</span><span class="p">)</span>
<span class="linenos">178</span><span class="w">      </span><span class="n">qids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">QReg</span><span class="p">[</span><span class="n">qubit</span><span class="p">]));</span>
<span class="linenos">179</span>
<span class="linenos">180</span><span class="w">    </span><span class="c1">// Set all the mapping angles to the default of 0.</span>
<span class="linenos">181</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">map_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">map_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_map_angles</span><span class="p">;</span><span class="w"> </span><span class="n">map_index</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">182</span><span class="w">      </span><span class="n">QMapParams</span><span class="p">[</span><span class="n">map_index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">183</span>
<span class="linenos">184</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">indx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">indx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">variable_params</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">indx</span><span class="p">)</span>
<span class="linenos">185</span><span class="w">      </span><span class="n">QMapParams</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">variable_params</span><span class="p">[</span><span class="n">indx</span><span class="p">];</span>
<span class="linenos">186</span>
<span class="linenos">187</span><span class="w">    </span><span class="c1">// Perform the experiment, Store the data in ProbReg</span>
<span class="linenos">188</span><span class="w">    </span><span class="n">TFD_full</span><span class="p">();</span>
<span class="linenos">189</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ProbReg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sim_device</span><span class="p">.</span><span class="n">getProbabilities</span><span class="p">(</span><span class="n">qids</span><span class="p">);</span>
<span class="linenos">190</span>
<span class="linenos">191</span><span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">current_pstr_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hqcl</span><span class="o">::</span><span class="n">SymbolicOperatorUtils</span><span class="o">::</span><span class="n">getExpectValSetOfPaulis</span><span class="p">(</span>
<span class="linenos">192</span><span class="w">        </span><span class="n">symb_op</span><span class="p">,</span><span class="w"> </span><span class="n">qwc_group</span><span class="p">.</span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="n">ProbReg</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="linenos">193</span><span class="w">    </span><span class="n">total_cost</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">current_pstr_val</span><span class="p">;</span>
<span class="linenos">194</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">195</span>
<span class="linenos">196</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">total_cost</span><span class="p">;</span>
<span class="linenos">197</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">runQuantumKernel</span></code> encompasses all the functionality that is
required to calculate the cost, when running a single optimization iteration
with <code class="docutils literal notranslate"><span class="pre">dlib</span></code>. It takes the already formulated set of QWC groups, and run
the ansatz with the same set of variational parameters but with different basis
mapping parameters (each time mapping from the different bases, as demanded by
the cost expression). The full cost is then returned for consideration by the
classical optimization loop within <code class="docutils literal notranslate"><span class="pre">dlib</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="tfd-main">
<div class="code-block-caption"><span class="caption-number">Listing 21 </span><span class="caption-text">The <code class="docutils literal notranslate"><span class="pre">main</span></code> function.</span><a class="headerlink" href="#tfd-main" title="Link to this code">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">199</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">200</span><span class="w">    </span><span class="c1">// Setup quantum device</span>
<span class="linenos">201</span><span class="w">    </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">IqsConfig</span><span class="w"> </span><span class="n">sim_config</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;noiseless&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="linenos">202</span><span class="w">    </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">FullStateSimulator</span><span class="w"> </span><span class="n">sim_device</span><span class="p">(</span><span class="n">sim_config</span><span class="p">);</span>
<span class="linenos">203</span><span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">sim_device</span><span class="p">.</span><span class="n">ready</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">iqsdk</span><span class="o">::</span><span class="n">QRT_ERROR_SUCCESS</span><span class="p">);</span>
<span class="linenos">204</span>
<span class="linenos">205</span><span class="w">    </span><span class="c1">// initial starting point. Defining it here means I will reuse the best result</span>
<span class="linenos">206</span><span class="w">    </span><span class="c1">// from previous temperature when starting the next temperature run</span>
<span class="linenos">207</span><span class="w">    </span><span class="n">column_vector</span><span class="w"> </span><span class="n">starting_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span>
<span class="linenos">208</span>
<span class="linenos">209</span><span class="w">    </span><span class="c1">// calculate the actual inverse temperature that is used during calculations</span>
<span class="linenos">210</span><span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">inv_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="linenos">211</span>
<span class="linenos">212</span><span class="w">    </span><span class="c1">// Fully formulated Cost Function Expression</span>
<span class="linenos">213</span><span class="w">    </span><span class="n">hqcl</span><span class="o">::</span><span class="n">SymbolicOperator</span><span class="w"> </span><span class="n">cost_expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">constructFullSymbOp</span><span class="p">(</span><span class="n">inv_temp</span><span class="p">);</span>
<span class="linenos">214</span>
<span class="linenos">215</span><span class="w">    </span><span class="c1">// Qubitwise Commutation (QWC) Groups Formation</span>
<span class="linenos">216</span><span class="w">    </span><span class="n">hqcl</span><span class="o">::</span><span class="n">QWCMap</span><span class="w"> </span><span class="n">qwc_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hqcl</span><span class="o">::</span><span class="n">SymbolicOperatorUtils</span><span class="o">::</span><span class="n">getQubitwiseCommutationGroups</span><span class="p">(</span><span class="n">cost_expr</span><span class="p">);</span>
<span class="linenos">217</span>
<span class="linenos">218</span><span class="w">    </span><span class="c1">// Construct a function to be used for a single optimization iteration</span>
<span class="linenos">219</span><span class="w">    </span><span class="c1">// This function is directly called by the dlib optimization routine</span>
<span class="linenos">220</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ansatz_run_lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">column_vector</span><span class="o">&amp;</span><span class="w"> </span><span class="n">var_angs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">221</span>
<span class="linenos">222</span><span class="w">      </span><span class="c1">// Set all the variational angles to input values.</span>
<span class="linenos">223</span><span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">q_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">q_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N_map_angles</span><span class="p">;</span><span class="w"> </span><span class="n">q_index</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">224</span><span class="w">          </span><span class="n">QVarParams</span><span class="p">[</span><span class="n">q_index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">var_angs</span><span class="p">(</span><span class="n">q_index</span><span class="p">);</span>
<span class="linenos">225</span>
<span class="linenos">226</span><span class="w">      </span><span class="c1">// run the kernel to compute the total cost</span>
<span class="linenos">227</span><span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">total_cost</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">runQuantumKernel</span><span class="p">(</span><span class="n">sim_device</span><span class="p">,</span><span class="w"> </span><span class="n">var_angs</span><span class="p">,</span><span class="w"> </span><span class="n">cost_expr</span><span class="p">,</span><span class="w"> </span><span class="n">qwc_groups</span><span class="p">);</span>
<span class="linenos">228</span>
<span class="linenos">229</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">total_cost</span><span class="p">;</span>
<span class="linenos">230</span><span class="w">    </span><span class="p">};</span>
<span class="linenos">231</span>
<span class="linenos">232</span><span class="w">    </span><span class="c1">// run the full optimization for a given temperature</span>
<span class="linenos">233</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dlib</span><span class="o">::</span><span class="n">find_min_bobyqa</span><span class="p">(</span>
<span class="linenos">234</span><span class="w">                        </span><span class="n">ansatz_run_lambda</span><span class="p">,</span><span class="w"> </span><span class="n">starting_point</span><span class="p">,</span>
<span class="linenos">235</span><span class="w">                        </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">N_var_angles</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// number of interpolation points</span>
<span class="linenos">236</span><span class="w">                        </span><span class="n">dlib</span><span class="o">::</span><span class="n">uniform_matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">N_var_angles</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">-7.0</span><span class="p">),</span><span class="w"> </span><span class="c1">// lower bound constraint</span>
<span class="linenos">237</span><span class="w">                        </span><span class="n">dlib</span><span class="o">::</span><span class="n">uniform_matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">N_var_angles</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">7.0</span><span class="p">),</span><span class="w"> </span><span class="c1">// upper bound constraint</span>
<span class="linenos">238</span><span class="w">                        </span><span class="mf">1.5</span><span class="p">,</span><span class="w"> </span><span class="c1">// initial trust region radius</span>
<span class="linenos">239</span><span class="w">                        </span><span class="mf">1e-5</span><span class="p">,</span><span class="w"> </span><span class="c1">// stopping trust region radius</span>
<span class="linenos">240</span><span class="w">                        </span><span class="mi">10000</span><span class="w"> </span><span class="c1">// max number of objective function evaluations</span>
<span class="linenos">241</span><span class="w">    </span><span class="p">);</span>
<span class="linenos">242</span>
<span class="linenos">243</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">244</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>The main function shown in <a class="reference internal" href="#tfd-main"><span class="std std-numref">Listing 21</span></a> will initialize the IQSDK backend,
construct the cost
expression, and kick off the optimization. The lambda function
<code class="docutils literal notranslate"><span class="pre">ansatz_run_lambda</span></code> is used since <code class="docutils literal notranslate"><span class="pre">dlib</span></code> requires the function used during
optimization to take a column vector as an input and to return a double. This
function essentially wraps the previously-defined <code class="docutils literal notranslate"><span class="pre">runQuantumKernel</span></code> function.</p>
</section>
</section>
<section id="results">
<h2>Results<a class="headerlink" href="#results" title="Link to this heading">¶</a></h2>
<p>The execution of the above program can be tracked with a log of the angles and
the cost function at each iteration. The summarized results are shown in
<a class="reference internal" href="#anglesplot"><span class="std std-numref">Fig. 2</span></a> and <a class="reference internal" href="#costplot"><span class="std std-numref">Fig. 3</span></a>.
These plots demonstrate that 95 steps are required for convergence to the requested
tolerance level.</p>
<figure class="align-default" id="anglesplot">
<span id="before-anglesplot"></span><a class="reference internal image-reference" href="../_images/anglesPlot.png"><img alt="../_images/anglesPlot.png" src="../_images/anglesPlot.png" style="width: 75%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2 </span><span class="caption-text">Convergence behavior for the four variational angles (see <span id="id15">[<a class="reference internal" href="../citations.html#id28" title="Shavindra P. Premaratne and A. Y. Matsuura. Engineering a cost function for real-world implementation of a variational quantum algorithm. In 2020 IEEE International Conference on Quantum Computing and Engineering (QCE), volume, 278-285. 2020. doi:10.1109/QCE49297.2020.00042.">PM20</a>]</span> <span id="id16">[<a class="reference internal" href="../citations.html#id29" title="R Sagastizabal, SP Premaratne, BA Klaver, MA Rol, V Negîrneac, MS Moreira, X Zou, S Johri, N Muthusubramanian, M Beekman, and others. Variational preparation of finite-temperature states on a quantum computer. npj Quantum Information, 7(1):130, 2021. doi:10.1038/s41534-021-00468-1.">SPK+21</a>]</span> for details on the notation).</span><a class="headerlink" href="#anglesplot" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="costplot">
<a class="reference internal image-reference" href="../_images/costPlot.png"><img alt="../_images/costPlot.png" src="../_images/costPlot.png" style="width: 75%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 3 </span><span class="caption-text">Convergence of the evaluated cost during the variational algorithm execution.</span><a class="headerlink" href="#costplot" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="using-qbit-variables">
<h1>Using <code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables<a class="headerlink" href="#using-qbit-variables" title="Link to this heading">¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">qbit</span></code> is the data type for representing qubits. Variables of <code class="docutils literal notranslate"><span class="pre">qbit</span></code> type can be declared in the global
namespace or locally within a <code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code> function. Similar to locally declared classical C++ variables,
locally declared <code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables’ scope is limited to the <code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code> function they are declared in.</p>
<p>When a locally declared <code class="docutils literal notranslate"><span class="pre">qbit</span></code> variable goes out of scope, the quantum state is not automatically released.
This means in subsequent computation, the physical qubit associated to this variable might be reassgined to a different <code class="docutils literal notranslate"><span class="pre">qbit</span></code> while
still holding the now out-of-scope variable’s quantum state. Without proper handling, this could lead to unreliable
results. One option is to use <code class="docutils literal notranslate"><span class="pre">release_quantum_state()</span></code> at the end of the <code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code> in which local <code class="docutils literal notranslate"><span class="pre">qbit</span></code>
variables are declared. See <a class="reference internal" href="../dgr/programming.html#qbit"><span class="std std-ref">Local qbit Variables</span></a>. Examples can be found below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">qbit</span><span class="w"> </span><span class="n">global_qbit</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="n">quantum_kernel</span><span class="w"> </span><span class="nf">exampleReleaseOnMeasurement</span><span class="p">(){</span>
<span class="w">   </span><span class="n">qbit</span><span class="w"> </span><span class="n">local_3</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w">     </span><span class="c1">// declare a quantum array with 3 qbits</span>

<span class="w">   </span><span class="c1">// Prep the local qbit variables</span>
<span class="w">   </span><span class="n">PrepZ</span><span class="p">(</span><span class="n">local_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">   </span><span class="n">PrepZ</span><span class="p">(</span><span class="n">local_3</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">   </span><span class="n">PrepZ</span><span class="p">(</span><span class="n">local_3</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

<span class="w">   </span><span class="n">RY</span><span class="p">(</span><span class="n">local_3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span>
<span class="w">   </span><span class="n">RY</span><span class="p">(</span><span class="n">local_3</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span>
<span class="w">   </span><span class="n">RY</span><span class="p">(</span><span class="n">local_3</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span>

<span class="w">   </span><span class="c1">// Measuring the qbit variables</span>
<span class="w">   </span><span class="n">MeasX</span><span class="p">(</span><span class="n">local_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">   </span><span class="n">MeasX</span><span class="p">(</span><span class="n">local_3</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">   </span><span class="n">MeasX</span><span class="p">(</span><span class="n">local_3</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">   </span><span class="c1">// After the measurements, the physical qubits assigned to local_3 are released</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">quantum_kernel</span><span class="w"> </span><span class="nf">exampleExplicitRelease</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">qbit</span><span class="w"> </span><span class="n">q0</span><span class="p">;</span>
<span class="w">   </span><span class="n">qbit</span><span class="w"> </span><span class="n">q1</span><span class="p">;</span>

<span class="w">   </span><span class="n">PrepZ</span><span class="p">(</span><span class="n">q0</span><span class="p">);</span>
<span class="w">   </span><span class="n">PrepZ</span><span class="p">(</span><span class="n">q1</span><span class="p">);</span>

<span class="w">   </span><span class="n">RZ</span><span class="p">(</span><span class="n">q0</span><span class="p">);</span>
<span class="w">   </span><span class="n">RZ</span><span class="p">(</span><span class="n">q1</span><span class="p">);</span>
<span class="w">   </span><span class="n">RZ</span><span class="p">(</span><span class="n">global_qbit</span><span class="p">);</span>

<span class="w">   </span><span class="n">release_quantum_state</span><span class="p">();</span>
<span class="w">   </span><span class="c1">// After the call to release_quantum_state(), all qubits, including the global qbit,</span>
<span class="w">   </span><span class="c1">// are released from this point onwards and the physical qubits can be</span>
<span class="w">   </span><span class="c1">// reused in a new ``quantum_kernel``</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">quantum_kernel</span><span class="w"> </span><span class="nf">badExampleNoRelease</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// In this example, the local qubits are not properly released at the end of the kernel</span>
<span class="w">   </span><span class="n">qbit</span><span class="w"> </span><span class="n">q0</span><span class="p">;</span>
<span class="w">   </span><span class="n">qbit</span><span class="w"> </span><span class="n">q1</span><span class="p">;</span>

<span class="w">   </span><span class="n">PrepZ</span><span class="p">(</span><span class="n">q0</span><span class="p">);</span>
<span class="w">   </span><span class="n">PrepZ</span><span class="p">(</span><span class="n">q1</span><span class="p">);</span>

<span class="w">   </span><span class="n">RZ</span><span class="p">(</span><span class="n">q0</span><span class="p">);</span>
<span class="w">   </span><span class="n">RZ</span><span class="p">(</span><span class="n">q1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">quantum_kernel</span><span class="w"> </span><span class="nf">badExample</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">   </span><span class="c1">// This program will not cause a compilation error</span>
<span class="w">   </span><span class="c1">// However the computed results might be incorrect</span>
<span class="w">   </span><span class="c1">// as the second call to badExampleNoRelease() might be using the same</span>
<span class="w">   </span><span class="c1">// physical qubits which are in unknown states</span>
<span class="w">   </span><span class="n">badExampleNoRelease</span><span class="p">();</span>
<span class="w">   </span><span class="n">badExampleNoRelease</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables can be passed as arguments of <code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code> functions with the exception of top level
<code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code> functions, which do not take quantum-type parameters.
<code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables must be passed by reference.
If passed by value, a local copy of the input <code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables will be made,
just as for classical variables.
Since quantum states cannot be copied, passing a <code class="docutils literal notranslate"><span class="pre">qbit</span></code> by value has no physical
meaning and will cause an error when compiling, .
Examples of how to pass <code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables as inputs to
<code class="docutils literal notranslate"><span class="pre">quantum_kernel</span></code> functions are shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">qbit</span><span class="w"> </span><span class="n">global_qbit</span><span class="p">;</span>

<span class="c1">// Pass by pointer - accepted behaviour</span>
<span class="kt">void</span><span class="w"> </span><span class="n">quantum_kernel</span><span class="w"> </span><span class="nf">passQubitArrayByPtr</span><span class="p">(</span><span class="n">qbit</span><span class="w"> </span><span class="n">qubit_array</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_ele</span><span class="p">){</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_ele</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">      </span><span class="n">H</span><span class="p">(</span><span class="n">qubit_array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="c1">// Pass by pointer - accepted behaviour</span>
<span class="kt">void</span><span class="w"> </span><span class="n">quantum_kernel</span><span class="w"> </span><span class="nf">passQubitArrayByPtr2</span><span class="p">(</span><span class="n">qbit</span><span class="w"> </span><span class="o">*</span><span class="n">qubit_array</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_ele</span><span class="p">){</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_ele</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">      </span><span class="n">H</span><span class="p">(</span><span class="n">qubit_array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="c1">// Pass by reference - accepted behaviour</span>
<span class="kt">void</span><span class="w"> </span><span class="n">quantum_kernel</span><span class="w"> </span><span class="nf">passQubitByRef</span><span class="p">(</span><span class="n">qbit</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">){</span>
<span class="w">   </span><span class="n">Z</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Pass by value - will result in a compilation error</span>
<span class="kt">void</span><span class="w"> </span><span class="n">quantum_kernel</span><span class="w"> </span><span class="nf">passQubitByValue</span><span class="p">(</span><span class="n">qbit</span><span class="w"> </span><span class="n">q</span><span class="p">){</span>
<span class="w">   </span><span class="n">Z</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Note that the top level quantum_kernel does not take quantum arguments</span>
<span class="kt">void</span><span class="w"> </span><span class="n">quantum_kernel</span><span class="w"> </span><span class="nf">top_level_kernel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">qbit</span><span class="w"> </span><span class="n">qubit_array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="w">   </span><span class="n">passQubitArrayByPtr</span><span class="p">(</span><span class="n">qubit_array</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">   </span><span class="n">passQubitArrayByPtr2</span><span class="p">(</span><span class="n">qubit_array</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">   </span><span class="n">passQubitByRef</span><span class="p">(</span><span class="n">global_qbit</span><span class="p">);</span>
<span class="w">   </span><span class="n">passQubitByValue</span><span class="p">(</span><span class="n">global_qbit</span><span class="p">);</span><span class="w">   </span><span class="c1">// Pass by value - will result in a compilation error</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The minimum number of physical qubits required in a program is the sum of all global <code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables plus the
maximum width of local <code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables. In the following example, the minimum number of physical qubits needed
is 8, comprising the 3 global <code class="docutils literal notranslate"><span class="pre">qbit</span></code> and the 5 <code class="docutils literal notranslate"><span class="pre">qbit</span></code> inside <code class="docutils literal notranslate"><span class="pre">circuitWidth5</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">qbit</span><span class="w"> </span><span class="n">global_qbit</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="kt">void</span><span class="w"> </span><span class="n">quantum_kernel</span><span class="w"> </span><span class="nf">circuitWidth2</span><span class="p">(){</span>
<span class="w">   </span><span class="n">qbit</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">quantum_kernel</span><span class="w"> </span><span class="nf">circuitWidth5</span><span class="p">(){</span>
<span class="w">   </span><span class="n">qbit</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">quantum_kernel</span><span class="w"> </span><span class="nf">circuits</span><span class="p">(){</span>
<span class="w">   </span><span class="n">circuitWidth2</span><span class="p">();</span>
<span class="w">   </span><span class="n">circuitWidth5</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When compiling with a configuration file, the <code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables will be mapped to physical qubits using
the placement method set by the <code class="docutils literal notranslate"><span class="pre">-p</span></code> flag. All <code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables, both global and locally declared, will
be mapped using the same method, with the exception that only global <code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables can be mapped by
user defined mapping. See <a class="reference internal" href="../dgr/compiler.html#placement-and-scheduling"><span class="std std-ref">Qubit Placement and Scheduling</span></a>.</p>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Intel® Quantum SDK API</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting_started/index.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dgr/index.html">Developers Guide and Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fleq/index.html">FLEQ Guide and Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorials</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">A Tour of GHZ examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-release-quantum-state">Using <code class="docutils literal notranslate"><span class="pre">release_quantum_state()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#writing-variational-algorithms">Writing Variational Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-qbit-variables">Using <code class="docutils literal notranslate"><span class="pre">qbit</span></code> variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="qexpr-teleport.html">Quantum Teleportation with FLEQ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citations.html">Citations</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Tutorials</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Tutorials</a></li>
      <li>Next: <a href="qexpr-teleport.html" title="next chapter">Quantum Teleportation with FLEQ</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024 Intel Corporation. All Rights Reserved.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/tutorial/tutorials.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>